# Reglas de Desarrollo - Arreglalo App (Flutter 2025)
# Arquitectura: MVVM + SOLID + POO + Clean Code

## ğŸ—ï¸ Arquitectura: MVVM (Model-View-ViewModel)

### Estructura de MÃ³dulos
Cada mÃ³dulo debe seguir esta estructura:
```
modules/
  â”œâ”€â”€ {module_name}/
      â”œâ”€â”€ models/          # Modelos de datos especÃ­ficos del mÃ³dulo
      â”œâ”€â”€ views/           # UI (Widgets/Pages)
      â”œâ”€â”€ controllers/     # ViewModels (lÃ³gica de presentaciÃ³n)
      â”œâ”€â”€ bindings/        # InyecciÃ³n de dependencias (GetX)
      â””â”€â”€ repositories/    # Acceso a datos
```

### Principios MVVM
- **Model**: Clases de datos inmutables con `fromJson`/`toJson`
- **View**: Widgets Stateless/Stateful sin lÃ³gica de negocio
- **ViewModel/Controller**: Maneja estado y lÃ³gica de presentaciÃ³n usando GetX
- **Repository**: Abstrae acceso a datos (Supabase, API, local storage)

## ğŸ¯ Principios SOLID

### Single Responsibility Principle (SRP)
- Cada clase/archivo debe tener UNA sola razÃ³n para cambiar
- Separa lÃ³gica de negocio, presentaciÃ³n y acceso a datos
- Un widget = una responsabilidad UI
- Un controller = una responsabilidad de estado/lÃ³gica

### Open/Closed Principle (OCP)
- Abre para extensiÃ³n, cierra para modificaciÃ³n
- Usa interfaces y abstracciones para repositorios
- Extiende funcionalidad con composiciÃ³n, no herencia

### Liskov Substitution Principle (LSP)
- Las implementaciones deben ser intercambiables
- Los repositorios deben cumplir sus contratos sin romper expectativas

### Interface Segregation Principle (ISP)
- Interfaces pequeÃ±as y especÃ­ficas
- No fuerces a clases a implementar mÃ©todos que no usan
- Usa mixins para funcionalidades compartidas opcionales

### Dependency Inversion Principle (DIP)
- Depende de abstracciones, no de implementaciones concretas
- Inyecta dependencias en constructores
- Usa GetX Bindings para inyecciÃ³n de dependencias

## ğŸ’¼ ProgramaciÃ³n Orientada a Objetos (POO)

### Clases y EncapsulaciÃ³n
- Campos privados con `_` (underscore)
- Getters pÃºblicos cuando sea necesario
- Constructores con parÃ¡metros nombrados
- Factory constructors para casos especiales

### Herencia vs ComposiciÃ³n
- **Prefiere composiciÃ³n sobre herencia**
- Usa mixins para reutilizaciÃ³n de cÃ³digo
- Herencia solo para relaciones IS-A claras

### Polimorfismo
- Interfaces para definir contratos
- Implementaciones mÃºltiples de la misma interfaz
- MÃ©todos abstractos en clases base cuando sea apropiado

### AbstracciÃ³n
- Interfaces/abstract classes para contratos
- Implementaciones concretas en clases derivadas
- No exponas detalles de implementaciÃ³n

## ğŸ§© Modelos de Datos (Prioridad sobre Mapas)

### SIEMPRE crear modelos tipados
```dart
// âœ… CORRECTO: Usar modelo tipado
class UserModel {
  final String id;
  final String email;
  final String? name;
  final DateTime createdAt;
  
  UserModel({
    required this.id,
    required this.email,
    this.name,
    required this.createdAt,
  });
  
  factory UserModel.fromJson(Map<String, dynamic> json) => UserModel(
    id: json['id'] as String,
    email: json['email'] as String,
    name: json['name'] as String?,
    createdAt: DateTime.parse(json['created_at'] as String),
  );
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'name': name,
    'created_at': createdAt.toIso8601String(),
  };
  
  UserModel copyWith({
    String? id,
    String? email,
    String? name,
    DateTime? createdAt,
  }) => UserModel(
    id: id ?? this.id,
    email: email ?? this.email,
    name: name ?? this.name,
    createdAt: createdAt ?? this.createdAt,
  );
}
```

### NUNCA usar Mapas directamente
```dart
// âŒ INCORRECTO: No usar Mapas directamente
Future<void> saveUser(Map<String, dynamic> userData) async {
  await repository.save(userData);
}

// âœ… CORRECTO: Usar modelos tipados
Future<void> saveUser(UserModel user) async {
  await repository.save(user.toJson());
}
```

### Reglas para Modelos
- Todos los campos deben ser `final` (inmutabilidad)
- Constructor con parÃ¡metros nombrados y `required` explÃ­cito
- Factory `fromJson` para deserializaciÃ³n
- MÃ©todo `toJson` para serializaciÃ³n
- MÃ©todo `copyWith` para crear copias modificadas
- ValidaciÃ³n de tipos en `fromJson` (usar `as` o validaciÃ³n explÃ­cita)
- Campos opcionales marcados con `?`
- Valores por defecto cuando sea apropiado

## ğŸ§© Widgets Reutilizables y Globales

### Principios de Widgets Reutilizables
- **Un widget = una responsabilidad UI**
- MÃ¡ximo 100 lÃ­neas por widget (extraer a sub-widgets si excede)
- Props claras y bien documentadas
- Const constructors cuando sea posible
- ParÃ¡metros con valores por defecto apropiados

### Estructura de Widgets Globales
```
lib/
  â”œâ”€â”€ presentation/
      â””â”€â”€ widgets/
          â”œâ”€â”€ buttons/        # Botones reutilizables
          â”œâ”€â”€ inputs/         # Campos de entrada
          â”œâ”€â”€ cards/          # Tarjetas reutilizables
          â”œâ”€â”€ dialogs/        # DiÃ¡logos modales
          â”œâ”€â”€ loaders/        # Indicadores de carga
          â””â”€â”€ common/         # Widgets comunes varios
```

### Ejemplo de Widget Reutilizable
```dart
/// BotÃ³n primario reutilizable con mÃºltiples variantes
class AppButton extends StatelessWidget {
  const AppButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.variant = AppButtonVariant.primary,
    this.isLoading = false,
    this.icon,
    this.fullWidth = false,
  });
  
  final String label;
  final VoidCallback? onPressed;
  final AppButtonVariant variant;
  final bool isLoading;
  final IconData? icon;
  final bool fullWidth;
  
  @override
  Widget build(BuildContext context) {
    final button = ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: _getButtonStyle(context),
      child: isLoading
          ? const SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          : Row(
              mainAxisSize: fullWidth ? MainAxisSize.max : MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                if (icon != null) ...[
                  Icon(icon, size: 18),
                  const SizedBox(width: 8),
                ],
                Text(label),
              ],
            ),
    );
    
    return fullWidth ? SizedBox(width: double.infinity, child: button) : button;
  }
  
  ButtonStyle _getButtonStyle(BuildContext context) {
    // LÃ³gica de estilos segÃºn variant
  }
}
```

### Reglas para Widgets
- Documentar props con comentarios `///`
- Usar `const` cuando sea posible
- Extraer lÃ³gica compleja a mÃ©todos privados `_build*`
- MÃ¡ximo 100 lÃ­neas, extraer a sub-widgets si excede
- Manejar estados de carga, error y vacÃ­o
- Usar keys cuando sea necesario para optimizaciÃ³n

## ğŸ§ª Testing

### Cobertura de Tests Requerida
- **Unit Tests**: Para toda la lÃ³gica de negocio (controllers, repositories, services)
- **Widget Tests**: Para widgets reutilizables y componentes crÃ­ticos
- **Integration Tests**: Para flujos de usuario completos
- **MÃ­nimo 80% de cobertura** para cÃ³digo crÃ­tico

### Estructura de Tests
```
test/
  â”œâ”€â”€ unit/
  â”‚   â”œâ”€â”€ controllers/
  â”‚   â”œâ”€â”€ repositories/
  â”‚   â”œâ”€â”€ services/
  â”‚   â””â”€â”€ models/
  â”œâ”€â”€ widget/
  â”‚   â””â”€â”€ widgets/
  â””â”€â”€ integration/
      â””â”€â”€ flows/
```

### Ejemplo de Test Unitario
```dart
// test/unit/controllers/auth_controller_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:get/get.dart';

class MockAuthRepository extends Mock implements AuthRepository {}

void main() {
  late AuthController controller;
  late MockAuthRepository mockRepository;
  
  setUp(() {
    mockRepository = MockAuthRepository();
    controller = AuthController(mockRepository);
  });
  
  tearDown(() {
    Get.reset();
  });
  
  group('AuthController', () {
    test('login debe establecer usuario cuando credenciales son vÃ¡lidas', () async {
      // Arrange
      final user = UserModel(id: '1', email: 'test@test.com');
      when(mockRepository.login('test@test.com', 'password'))
          .thenAnswer((_) async => user);
      
      // Act
      await controller.login('test@test.com', 'password');
      
      // Assert
      expect(controller.currentUser, equals(user));
      expect(controller.isLoggedIn.value, isTrue);
    });
    
    test('login debe establecer error cuando credenciales son invÃ¡lidas', () async {
      // Arrange
      when(mockRepository.login('test@test.com', 'wrong'))
          .thenThrow(AuthException('Invalid credentials'));
      
      // Act
      await controller.login('test@test.com', 'wrong');
      
      // Assert
      expect(controller.error.value, contains('Invalid credentials'));
      expect(controller.isLoggedIn.value, isFalse);
    });
  });
}
```

### Ejemplo de Widget Test
```dart
// test/widget/widgets/app_button_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

void main() {
  group('AppButton', () {
    testWidgets('debe mostrar label correctamente', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: AppButton(
              label: 'Click me',
              onPressed: () {},
            ),
          ),
        ),
      );
      
      expect(find.text('Click me'), findsOneWidget);
    });
    
    testWidgets('debe mostrar loading cuando isLoading es true', (tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: AppButton(
              label: 'Loading',
              onPressed: () {},
              isLoading: true,
            ),
          ),
        ),
      );
      
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
      expect(find.text('Loading'), findsNothing);
    });
  });
}
```

### Reglas de Testing
- Un test por comportamiento/caso de uso
- Arrange-Act-Assert (AAA) pattern
- Nombres descriptivos: `test('debe hacer X cuando Y')`
- Mockear dependencias externas
- Tests independientes (sin dependencias entre tests)
- Limpiar estado entre tests (setUp/tearDown)

## ğŸ“ Nomenclatura y Convenciones

### Clases
- PascalCase con sufijos descriptivos:
  - `*Model` para modelos de datos
  - `*Controller` para controladores/ViewModels
  - `*View` para vistas/pÃ¡ginas
  - `*Widget` para widgets reutilizables
  - `*Repository` para repositorios
  - `*Service` para servicios
  - `*Binding` para bindings de GetX

### Variables y MÃ©todos
- camelCase para variables y mÃ©todos
- Variables privadas con prefijo `_`
- MÃ©todos privados con prefijo `_`
- MÃ©todos de construcciÃ³n UI: `_build*`
- Nombres descriptivos y autoexplicativos

### Constantes
- SCREAMING_SNAKE_CASE para constantes globales
- camelCase para constantes de clase estÃ¡ticas
- Uso de `const` cuando sea posible

## ğŸ¨ Clean Code Principles

### CÃ³digo Limpio
- **Nombres descriptivos**: El cÃ³digo debe leerse como documentaciÃ³n
- **Funciones pequeÃ±as**: Una funciÃ³n = una cosa
- **MÃ¡ximo 50 lÃ­neas por funciÃ³n** (ideal: 20-30)
- **MÃ¡ximo 100 lÃ­neas por clase/widget**
- **Sin comentarios obvios**: El cÃ³digo debe ser autoexplicativo
- **DRY**: Don't Repeat Yourself (extraer duplicaciÃ³n)
- **KISS**: Keep It Simple, Stupid

### Manejo de Errores
```dart
// âœ… CORRECTO: Manejo explÃ­cito de errores
try {
  final result = await repository.fetchData();
  return Success(result);
} on NetworkException catch (e) {
  return Failure(NetworkFailure(e.message));
} on ValidationException catch (e) {
  return Failure(ValidationFailure(e.message));
} catch (e) {
  return Failure(UnexpectedFailure(e.toString()));
}

// âŒ INCORRECTO: Catch genÃ©rico sin manejo
try {
  await repository.fetchData();
} catch (e) {
  print(e); // No hacer esto
}
```

### Null Safety
- Usar `?` para valores opcionales
- Usar `!` solo cuando estÃ©s 100% seguro (mejor usar `??` o verificaciÃ³n)
- Preferir `late` sobre `?` cuando la inicializaciÃ³n es garantizada
- Validar nulls explÃ­citamente antes de usar

## ğŸš« Sin Deuda TÃ©cnica

### Principios Anti-Deuda TÃ©cnica
- **No dejar cÃ³digo comentado** (usar Git para historial)
- **No dejar TODOs sin fecha/responsable**
- **Refactorizar antes de duplicar** cÃ³digo
- **Eliminar cÃ³digo muerto** (unused imports, mÃ©todos, variables)
- **Mantener dependencias actualizadas** (pero probadas)
- **Documentar decisiones complejas** con comentarios
- **No comprometer calidad por velocidad** (hacerlo bien desde el inicio)

### Code Review Checklist
- [ ] Â¿El cÃ³digo sigue MVVM?
- [ ] Â¿Cumple principios SOLID?
- [ ] Â¿Usa modelos en lugar de mapas?
- [ ] Â¿Widgets reutilizables cuando es apropiado?
- [ ] Â¿Tests escritos para nueva funcionalidad?
- [ ] Â¿Manejo de errores apropiado?
- [ ] Â¿Null safety manejado correctamente?
- [ ] Â¿Sin cÃ³digo duplicado?
- [ ] Â¿Nombres descriptivos y claros?
- [ ] Â¿Sin cÃ³digo comentado o muerto?

## ğŸ”§ Mejores PrÃ¡cticas Flutter 2025

### Performance
- Usar `const` constructors siempre que sea posible
- Evitar rebuilds innecesarios (usar `const`, `Obx` selectivo)
- Lazy loading de imÃ¡genes y widgets pesados
- Usar `ListView.builder` para listas largas
- Dispose de controllers, streams, focus nodes

### Estado
- GetX para estado global/compartido
- StatefulWidget solo para estado local simple
- Evitar setState innecesarios
- Usar `Obx` selectivo, no en toda la UI

### Async
- Usar `async/await` sobre `.then()`
- Manejar Future con try-catch
- Mostrar estados de carga/error/vacÃ­o
- Usar `FutureBuilder` para operaciones asÃ­ncronas en UI

### NavegaciÃ³n
- Usar GetX routing con rutas nombradas
- Bindings para inyecciÃ³n de dependencias
- Middleware para autenticaciÃ³n/validaciÃ³n
- Transiciones suaves y animaciones apropiadas

## ğŸ“ Estructura de Proyecto

```
lib/
  â”œâ”€â”€ core/
  â”‚   â”œâ”€â”€ constants/       # Constantes globales
  â”‚   â”œâ”€â”€ routes/          # ConfiguraciÃ³n de rutas
  â”‚   â”œâ”€â”€ theme/           # Tema y estilos
  â”‚   â”œâ”€â”€ utils/           # Utilidades globales
  â”‚   â””â”€â”€ services/        # Servicios globales (Firebase, etc.)
  â”œâ”€â”€ data/
  â”‚   â”œâ”€â”€ models/          # Modelos de datos
  â”‚   â”œâ”€â”€ repositories/    # Implementaciones de repositorios
  â”‚   â””â”€â”€ services/        # Servicios de datos (Supabase, etc.)
  â”œâ”€â”€ domain/
  â”‚   â”œâ”€â”€ entities/        # Entidades de dominio
  â”‚   â””â”€â”€ repositories/    # Interfaces de repositorios
  â””â”€â”€ presentation/
      â”œâ”€â”€ modules/         # MÃ³dulos de la app
      â”‚   â””â”€â”€ {module}/
      â”‚       â”œâ”€â”€ models/  # Modelos especÃ­ficos del mÃ³dulo
      â”‚       â”œâ”€â”€ views/   # UI
      â”‚       â”œâ”€â”€ controllers/  # ViewModels
      â”‚       â”œâ”€â”€ bindings/     # InyecciÃ³n de dependencias
      â”‚       â””â”€â”€ repositories/ # Repositorios del mÃ³dulo
      â””â”€â”€ widgets/         # Widgets reutilizables globales
          â”œâ”€â”€ buttons/
          â”œâ”€â”€ inputs/
          â”œâ”€â”€ cards/
          â””â”€â”€ common/
```

## ğŸ“‹ Checklist de Desarrollo

Antes de hacer commit, verificar:
- [ ] Â¿Sigue arquitectura MVVM?
- [ ] Â¿Cumple principios SOLID?
- [ ] Â¿Usa modelos tipados (no mapas)?
- [ ] Â¿Widgets son reutilizables cuando aplica?
- [ ] Â¿Tests escritos y pasando?
- [ ] Â¿Manejo de errores apropiado?
- [ ] Â¿Null safety correcto?
- [ ] Â¿Sin cÃ³digo duplicado?
- [ ] Â¿Nombres descriptivos?
- [ ] Â¿Sin cÃ³digo comentado/muerto?
- [ ] Â¿Performance optimizada (const, lazy loading)?
- [ ] Â¿Dispose de recursos correctamente?

## ğŸ¯ Prioridades

1. **Modelos tipados sobre mapas** - Siempre crear modelos
2. **Widgets reutilizables** - Evitar duplicaciÃ³n de UI
3. **Tests completos** - Cobertura mÃ­nima 80%
4. **Clean Code** - CÃ³digo legible y mantenible
5. **SOLID** - Principios de diseÃ±o aplicados
6. **MVVM** - SeparaciÃ³n clara de responsabilidades
7. **Sin deuda tÃ©cnica** - Hacerlo bien desde el inicio

---

**Recuerda**: El cÃ³digo se lee mÃ¡s veces de las que se escribe. Escribe cÃ³digo pensando en quien lo leerÃ¡ despuÃ©s (posiblemente tÃº mismo en 6 meses).
